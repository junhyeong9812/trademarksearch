## 상표 검색 API 구현을 위한 기술 선택 및 분석 과정

### 1. 문제 상황 분석: JSON 데이터의 특성과 요구사항 이해

제공된 `trademark_sample.json` 데이터를 처음 분석했을 때, 단순한 키워드 매칭으로는 해결되지 않는 다음과 같은 복합적인 문제 요소가 존재함을 발견했다:

- 한글과 영문이 혼재된 데이터 구조
- `productName`과 같은 주요 검색 필드가 `null`일 수도 있고, 리스트 형태인 필드도 존재
- 오타 또는 부분 일치 조건으로도 사용자가 원하는 결과를 찾아야 한다는 비정형 검색 요구
- 데이터량은 수백 건 수준이지만, 조건상 10만 건 이상의 확장 가능성까지 고려해야 함

이러한 특성은 단순한 DB 저장 + SQL `LIKE`문 기반 검색만으로는 부족하며, 고급 텍스트 분석 및 검색 최적화가 가능한 구조가 필요하다고 판단하였다.

### 2. 기술적 대안 고민: Python으로 자체 구현 vs 외부 검색 엔진 활용

초기에는 파이썬 단독으로 구현하는 방안을 고려하였다. 다음과 같은 구현 시나리오를 상정했다:

영문 검색 시나리오:

- 검색어 `move`에 대해 사용자가 `mive`로 오타 입력할 경우,
- 파이썬 내에서 소문자 통일 (`lower()`), 문자열 분리 (`list(str)`), 교정 후보 탐색 (`Levenshtein distance` 활용) 등을 조합하면 일정 수준의 검색 품질은 확보 가능

한글 검색 시나리오:

- 한글은 자음/모음 조합 방식으로 인해 조합 가능성이 기하급수적으로 증가
  - 예: `검정` → `감정`, `겅점`, `걺정`, `곪정` 등 수십~수백 개 후보
- 이를 위해 `KoNLPy`, `Okt`, `Mecab` 등 형태소 분석 라이브러리를 활용해야 하나,
  - 성능 이슈 + 모델 로딩 비용 + 분석 정확도 미달 등으로 API 서버에서 직접 처리하는 데는 무리가 있음

전체 데이터 메모리 로딩:

- `json` 파일을 전부 읽어 `list[dict]` 형태로 메모리에 유지하고 검색어 입력마다 순회하는 구조는:
  - 데이터 양이 많아질수록 메모리 사용량 급증
  - 검색 속도 저하 → 실시간 API로 제공하기에는 적합하지 않음
  - 탐색 속도가 가장 중요한 검색 시스템에서 부적절

### 3. 기술 대안 비교 및 Elasticsearch 최종 선택

다양한 기술 스택을 고려했을 때 다음과 같은 분석을 통해 Elasticsearch를 선택하였다:

3-1. RDBMS 기반 대안의 한계 (MySQL, MariaDB 등)

- `LIKE` 검색은 인덱스 미적용으로 느림
- JSON 구조를 테이블로 정규화하면 쿼리 복잡도 증가 + 성능 저하
- 대량 데이터(10만 건 이상)에서 확장성 없음
- 텍스트 탐색 중심 시스템에는 적합하지 않음

3-2. NoSQL 대안 고려

Redis

- 장점: 인메모리 기반으로 단건 조회는 빠름
- 단점: 검색 엔진용으로는 구조적 제약이 크며, JSON 저장과 고급 쿼리는 부적합

MongoDB

- 장점: BSON 기반으로 JSON 유사 구조 저장 가능
- 단점: 형태소 분석, 오타 교정, 유사 검색 기능 미흡. 복잡한 쿼리에 한계 있음

PostgreSQL + Full Text Search

- 장점: 일부 텍스트 검색 기능 내장
- 단점: 한국어 비지원, 복잡한 쿼리 및 확장성에서 Elasticsearch보다 열세

3-3. 최종 판단: Elasticsearch의 검색 중심 설계가 적합

| 조건                       | Elasticsearch 만족 여부                 |
| -------------------------- | --------------------------------------- |
| JSON 기반 데이터 저장      | 원시 형태 그대로 색인 가능              |
| 한글/영문 혼합 텍스트 분석 | `nori` 분석기 기반 형태소 처리          |
| 오타 대응 및 유사도 검색   | `fuzzy`, `match`, `multi_match` 등 지원 |
| 대량 문서 색인 및 검색     | 고성능 색인 + 수평 확장 (Shard 구조)    |
| RESTful API 연동           | FastAPI와의 통신 자연스러움 (JSON 기반) |
| 검색 로직 위임             | FastAPI는 라우팅에 집중, 검색은 ES 처리 |

### 4. 비교 관점: Elasticsearch vs 파이썬 라이브러리

| 기능                                 | Elasticsearch                  | 파이썬 라이브러리 구현 여부 | 난이도 |
| ------------------------------------ | ------------------------------ | --------------------------- | ------ |
| match, term, wildcard 검색           | 기본 제공                      | `in`, `re.search` 등        | 하     |
| N-gram, Edge-gram 분석               | 내장 분석기 사용               | 수작업 구현 필요            | 중상   |
| 오타 교정 (`fuzzy`, `edit_distance`) | 내장                           | `fuzzywuzzy`, `Levenshtein` | 중     |
| 형태소 분석 (한글)                   | `nori` 분석기 제공             | `KoNLPy`, `Mecab` 등 필요   | 중상   |
| 토큰화 및 필터 체인                  | 분석기 체인 조합 가능          | `spaCy`, `NLTK`, 직접 구현  | 중상   |
| 대량 문서 색인/검색                  | Shard/Cluster 구조로 확장 가능 | 메모리 한계 및 성능 저하    | 상     |

### 5. 과제 조건과의 직접적 연결

| 과제 조건                                 | 구현 방식 및 기술 선택                           |
| ----------------------------------------- | ------------------------------------------------ |
| 키워드가 정확히 일치하지 않아도 결과 제공 | `match`, `fuzzy`, `nori` 분석기 활용             |
| 검색 품질 향상                            | `multi_match`, boost 조정 등 ES의 검색 전략 활용 |
| 대량 데이터 확장성                        | ES 색인 구조와 수평 확장성 활용                  |
| 코드 효율성/가독성                        | FastAPI 도메인 구조 분리 + 설정 분리 (.env 등)   |

### 6. 결론

파이썬 자체 라이브러리만으로도 기본적인 문자열 검색이나 유사도 비교는 가능하다. 그러나:

- 한글 형태소 분석,
- 오타 교정,
- 고속 탐색,
- 수십만 건 이상의 대량 데이터 처리,
- 정밀한 검색 품질 보장

을 만족시키기 위해서는 Elasticsearch가 현 시점에서 가장 적합한 솔루션이었다.

따라서 이번 과제에서는 FastAPI + Elasticsearch 조합을 사용하여:

- 데이터를 Elasticsearch에 색인하고,
- 다양한 조건으로 고품질의 검색을 수행하며,
- API 서버는 가볍고 명확하게 역할을 분리하여 설계하는 방식으로 구현하였다.
