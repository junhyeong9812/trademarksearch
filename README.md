## 상표 검색 API 구현을 위한 기술 선택 및 분석 과정

### 1. 문제 상황 분석: JSON 데이터의 특성과 요구사항 이해

제공된 `trademark_sample.json` 데이터를 처음 분석했을 때, 단순한 키워드 매칭으로는 해결되지 않는 다음과 같은 복합적인 문제 요소가 존재함을 발견했다:

- 한글과 영문이 혼재된 데이터 구조
- `productName`과 같은 주요 검색 필드가 `null`일 수도 있고, 리스트 형태인 필드도 존재
- 오타 또는 부분 일치 조건으로도 사용자가 원하는 결과를 찾아야 한다는 비정형 검색 요구
- 데이터량은 수백 건 수준이지만, 조건상 10만 건 이상의 확장 가능성까지 고려해야 함

이러한 특성은 단순한 DB 저장 + SQL `LIKE`문 기반 검색만으로는 부족하며, 고급 텍스트 분석 및 검색 최적화가 가능한 구조가 필요하다고 판단하였다.

### 2. 기술적 대안 고민: Python으로 자체 구현 vs 외부 검색 엔진 활용

초기에는 파이썬 단독으로 구현하는 방안을 고려하였다. 다음과 같은 구현 시나리오를 상정했다:

영문 검색 시나리오:

- 검색어 `move`에 대해 사용자가 `mive`로 오타 입력할 경우,
- 파이썬 내에서 소문자 통일 (`lower()`), 문자열 분리 (`list(str)`), 교정 후보 탐색 (`Levenshtein distance` 활용) 등을 조합하면 일정 수준의 검색 품질은 확보 가능

한글 검색 시나리오:

- 한글은 자음/모음 조합 방식으로 인해 조합 가능성이 기하급수적으로 증가
  - 예: `검정` → `감정`, `겅점`, `걺정`, `곪정` 등 수십~수백 개 후보
- 이를 위해 `KoNLPy`, `Okt`, `Mecab` 등 형태소 분석 라이브러리를 활용해야 하나,
  - 성능 이슈 + 모델 로딩 비용 + 분석 정확도 미달 등으로 API 서버에서 직접 처리하는 데는 무리가 있음

전체 데이터 메모리 로딩:

- `json` 파일을 전부 읽어 `list[dict]` 형태로 메모리에 유지하고 검색어 입력마다 순회하는 구조는:
  - 데이터 양이 많아질수록 메모리 사용량 급증
  - 검색 속도 저하 → 실시간 API로 제공하기에는 적합하지 않음
  - 탐색 속도가 가장 중요한 검색 시스템에서 부적절

### 3. 기술 대안 비교 및 Elasticsearch 최종 선택

다양한 기술 스택을 고려했을 때 다음과 같은 분석을 통해 Elasticsearch를 선택하였다:

3-1. RDBMS 기반 대안의 한계 (MySQL, MariaDB 등)

- `LIKE` 검색은 인덱스 미적용으로 느림
- JSON 구조를 테이블로 정규화하면 쿼리 복잡도 증가 + 성능 저하
- 대량 데이터(10만 건 이상)에서 확장성 없음
- 텍스트 탐색 중심 시스템에는 적합하지 않음

3-2. NoSQL 대안 고려

Redis

- 장점: 인메모리 기반으로 단건 조회는 빠름
- 단점: 검색 엔진용으로는 구조적 제약이 크며, JSON 저장과 고급 쿼리는 부적합

MongoDB

- 장점: BSON 기반으로 JSON 유사 구조 저장 가능
- 단점: 형태소 분석, 오타 교정, 유사 검색 기능 미흡. 복잡한 쿼리에 한계 있음

PostgreSQL + Full Text Search

- 장점: 일부 텍스트 검색 기능 내장
- 단점: 한국어 비지원, 복잡한 쿼리 및 확장성에서 Elasticsearch보다 열세

3-3. 최종 판단: Elasticsearch의 검색 중심 설계가 적합

| 조건                       | Elasticsearch 만족 여부                 |
| -------------------------- | --------------------------------------- |
| JSON 기반 데이터 저장      | 원시 형태 그대로 색인 가능              |
| 한글/영문 혼합 텍스트 분석 | `nori` 분석기 기반 형태소 처리          |
| 오타 대응 및 유사도 검색   | `fuzzy`, `match`, `multi_match` 등 지원 |
| 대량 문서 색인 및 검색     | 고성능 색인 + 수평 확장 (Shard 구조)    |
| RESTful API 연동           | FastAPI와의 통신 자연스러움 (JSON 기반) |
| 검색 로직 위임             | FastAPI는 라우팅에 집중, 검색은 ES 처리 |

### 4. 비교 관점: Elasticsearch vs 파이썬 라이브러리

| 기능                                 | Elasticsearch                  | 파이썬 라이브러리 구현 여부 | 난이도 |
| ------------------------------------ | ------------------------------ | --------------------------- | ------ |
| match, term, wildcard 검색           | 기본 제공                      | `in`, `re.search` 등        | 하     |
| N-gram, Edge-gram 분석               | 내장 분석기 사용               | 수작업 구현 필요            | 중상   |
| 오타 교정 (`fuzzy`, `edit_distance`) | 내장                           | `fuzzywuzzy`, `Levenshtein` | 중     |
| 형태소 분석 (한글)                   | `nori` 분석기 제공             | `KoNLPy`, `Mecab` 등 필요   | 중상   |
| 토큰화 및 필터 체인                  | 분석기 체인 조합 가능          | `spaCy`, `NLTK`, 직접 구현  | 중상   |
| 대량 문서 색인/검색                  | Shard/Cluster 구조로 확장 가능 | 메모리 한계 및 성능 저하    | 상     |

### 5. 과제 조건과의 직접적 연결

| 과제 조건                                 | 구현 방식 및 기술 선택                           |
| ----------------------------------------- | ------------------------------------------------ |
| 키워드가 정확히 일치하지 않아도 결과 제공 | `match`, `fuzzy`, `nori` 분석기 활용             |
| 검색 품질 향상                            | `multi_match`, boost 조정 등 ES의 검색 전략 활용 |
| 대량 데이터 확장성                        | ES 색인 구조와 수평 확장성 활용                  |
| 코드 효율성/가독성                        | FastAPI 도메인 구조 분리 + 설정 분리 (.env 등)   |

### 6. 결론

파이썬 자체 라이브러리만으로도 기본적인 문자열 검색이나 유사도 비교는 가능하다. 그러나:

- 한글 형태소 분석,
- 오타 교정,
- 고속 탐색,
- 수십만 건 이상의 대량 데이터 처리,
- 정밀한 검색 품질 보장

을 만족시키기 위해서는 Elasticsearch가 현 시점에서 가장 적합한 솔루션이었다.

따라서 이번 과제에서는 FastAPI + Elasticsearch 조합을 사용하여:

- 데이터를 Elasticsearch에 색인하고,
- 다양한 조건으로 고품질의 검색을 수행하며,
- API 서버는 가볍고 명확하게 역할을 분리하여 설계하는 방식으로 구현하였다.

## 초성 검색 도입 배경 및 기술적 구현 고찰

### 1. 도입 배경: 사용자 편의성 향상을 위한 탐색

초성 검색 기능의 도입은 요구사항 명세에 따른 필수 항목이 아니라, "사용자가 어떻게 하면 더 적은 노력으로 원하는 결과를 빠르게 찾을 수 있을까?"라는 질문에서 시작되었다.

한글은 획수가 많은 언어이며, 특히 상표명처럼 기억이 불확실한 경우 초성 단위의 검색이 오히려 더 빠르고 직관적인 경우가 많다. 예를 들어 사용자가 "안드레아 구띠"를 정확히 기억하지 못하더라도 "ㅇㄷㄹㅇ ㄱㄸ"라는 초성만 입력해도 검색이 가능하다면 UX는 비약적으로 향상된다.

이러한 **한글 특화 검색 기법**은 단순한 유사도 검색이나 오타 교정으로는 구현이 어려운 부분이며, 초성 검색 도입은 한글 사용자에게만 제공할 수 있는 차별화된 검색 전략이기도 하다.

### 2. 구현 방식 비교: 실시간 처리 vs 색인 시 가공

초성 검색 구현에 있어 크게 두 가지 전략이 존재했다:

1. **검색 시점에 모든 데이터를 초성으로 변환하여 비교하는 실시간 처리 방식**

   - 장점: 기존 색인 구조 유지
   - 단점: 모든 문서 대상 반복 계산 → 속도 저하, 효율 낮음

2. **색인(Indexing) 시점에 초성 전용 필드를 생성하여 저장하고 검색 시 해당 필드를 활용하는 방식**

   - 장점: Elasticsearch의 색인 구조를 활용한 빠른 검색 가능
   - 단점: 별도의 데이터 전처리 필요 (초성 추출 로직)

성능과 확장성을 고려하여 우리는 두 번째 방식을 선택했다. Elasticsearch 색인 시 `productName_chosung`이라는 전용 필드를 함께 저장함으로써, 쿼리 시 match 또는 match_phrase_prefix 쿼리로 효율적인 검색이 가능하도록 했다.

### 3. 초성 추출 방식: 유니코드 기반 직접 구현 vs 라이브러리 활용

초성 필드를 만들기 위해 고려된 방식은 다음과 같다:

- 형태소 분석기(KoNLPy, Mecab 등)를 활용한 자모 분리
- Python 로직으로 직접 초성 추출 구현 (유니코드 기반)

우리는 두 번째 방식인 **유니코드 기반 직접 구현**을 선택했다. 이유는 다음과 같다:

- 형태소 분석기는 모델 로딩 시간, 종속성 설치, 성능 문제 등의 운영상 부담이 큼
- 초성 추출은 자모 분해 수준의 간단한 유니코드 연산만으로 충분히 가능

유니코드에서 한글은 0xAC00 (가)부터 시작해 초성, 중성, 종성의 조합으로 구성된다. 이때 초성 인덱스는 아래와 같은 방식으로 구할 수 있다:

```python
char_code = ord(char) - ord('가')
chosung_index = char_code // 588
result.append(CHOSUNG_LIST[chosung_index])
```

이처럼 한글 문자에만 유니코드 계산을 적용하고, 비한글 문자는 그대로 유지하는 방식으로 단순하면서도 정확한 초성 추출이 가능했다. 최종적으로 이 방식은 다음과 같은 장점을 가진다:

- 별도 라이브러리 불필요
- 성능이 빠르고 예측 가능
- 예외 처리가 간단함

### 4. 결론: 초성 검색은 UX 중심 설계의 결과

초성 검색은 사용자 경험(UX) 향상을 위한 전략적 선택이었다. 단순히 구현 가능한 기능이 아니라, **한글 사용자를 위한 직관적인 검색 경험 제공**, **입력 부담 완화**, **정확한 결과 도출**이라는 다각적인 목표를 만족시키기 위한 해법이었다.

Elasticsearch의 색인 최적화 구조와 유니코드 기반 초성 추출 로직을 조합함으로써, 성능과 품질을 모두 확보한 고도화된 검색 시스템을 구현할 수 있었다.
